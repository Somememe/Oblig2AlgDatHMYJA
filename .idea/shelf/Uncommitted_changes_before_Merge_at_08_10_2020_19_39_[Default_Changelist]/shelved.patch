Index: src/Oblig2/DobbeltLenketListe.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Oblig2;\r\n\r\n\r\n////////////////// class DobbeltLenketListe //////////////////////////////\r\n\r\n\r\nimport java.util.*;\r\n\r\nimport java.util.Iterator;\r\nimport java.util.Objects;\r\nimport java.util.function.Predicate;\r\n\r\n\r\n\r\npublic class DobbeltLenketListe<T> implements Liste<T> {\r\n\r\n    /**\r\n     * Node class\r\n     * @param <T>\r\n     */\r\n    private static final class Node<T> {\r\n        private T verdi;                   // nodens verdi\r\n        private Node<T> forrige, neste;    // pekere\r\n\r\n        private Node(T verdi, Node<T> forrige, Node<T> neste) {\r\n            this.verdi = verdi;\r\n            this.forrige = forrige;\r\n            this.neste = neste;\r\n        }\r\n\r\n        private Node(T verdi) {\r\n            this(verdi, null, null);\r\n        }\r\n    }\r\n\r\n    // instansvariabler\r\n    private Node<T> hode;          // peker til den første i listen\r\n    private Node<T> hale;          // peker til den siste i listen\r\n    private int antall;            // antall noder i listen\r\n    private int endringer;         // antall endringer i listen\r\n\r\n    public DobbeltLenketListe() {\r\n        hode = null;\r\n        hale = null;\r\n        antall = 0;\r\n        endringer = 0;\r\n    }\r\n\r\n    public DobbeltLenketListe(T[] a) throws NullPointerException {\r\n\r\n        Objects.requireNonNull(a, \"Tabellen a er null\");\r\n\r\n        for (int i = 0; i < a.length; i++) {\r\n            if(hode == null && a[i] != null){\r\n                hode = hale = new Node<>(a[i], null, null);\r\n                antall++;\r\n            }\r\n            else if (a[i] != null) {\r\n                hale = hale.neste = new Node(a[i], hale, null);\r\n                //hale = hale.forrige = new Node()\r\n                antall++;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private static void fraTilKontroll (int antall, int fra, int til) throws IndexOutOfBoundsException, IllegalArgumentException{\r\n\r\n        if (fra < 0 || til > antall) {\r\n            throw new IndexOutOfBoundsException(\"Ugyldig fra eller til indeks\");\r\n        }\r\n        if (fra > til) {\r\n            throw new IllegalArgumentException(\"Ugyldig intervall\");\r\n        }\r\n    }\r\n\r\n\r\n    public Liste<T> subliste(int fra, int til){\r\n        //hente ut elementer og lage det som en ny lenket liste, returnere en liste\r\n        //må kanskje lage en ny konstruktør\r\n        //sette hode-peker, hale-peker og antall\r\n        //sjekke om indekser fra og til er lovlige, om ikke skal det kastes unntak\r\n        fraTilKontroll(antall,fra,til);\r\n        int subAntall = 0;\r\n\r\n        Liste<T> liste = new DobbeltLenketListe<>();\r\n\r\n        for (int i = fra; i < til; i++) {\r\n            liste.leggInn(hent(i));\r\n            subAntall++;\r\n        }\r\n\r\n        return liste;\r\n    }\r\n\r\n    @Override\r\n    public int antall() {\r\n        /*\r\n        int antall = 0;\r\n\r\n        while(hode.neste != null){\r\n            antall++;\r\n        }\r\n        */\r\n        return antall;\r\n    }\r\n\r\n    @Override\r\n    public boolean tom() {\r\n        boolean erTom = true;\r\n\r\n        if(hode != null){\r\n            erTom = false;\r\n        }\r\n\r\n        return erTom;\r\n    }\r\n\r\n    //Y\r\n    @Override\r\n    public boolean leggInn(T verdi) throws UnsupportedOperationException {\r\n        Objects.requireNonNull(verdi, \"Ikke tillatt med null-verdier!\");\r\n\r\n        if (antall == 0)  {\r\n            hode = new Node<>(verdi, null, null);  // tom liste\r\n            hale = hode;\r\n        }\r\n        else {\r\n            hale.neste = new Node<>(verdi, hale, null); // legges bakerst\r\n            hale = hale.neste;\r\n        }\r\n\r\n        antall++;                  // en mer i listen\r\n        return true;               // vellykket innlegging\r\n\r\n        //throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void leggInn(int indeks, T verdi) {\r\n        Objects.requireNonNull(verdi, \"Ikke lov med null-verdier\");\r\n        //indeksKontroll(indeks, true);\r\n\r\n        if (indeks == 0) {\r\n            hode = new Node<>(verdi, hode, hode);\r\n            if (antall == 0) {\r\n                hale = hode;\r\n            }\r\n        } else if(indeks == antall) {\r\n            hale = hale.neste = new Node<>(verdi, null, null);\r\n        } else {\r\n            Node<T> p = hode;\r\n            for (int i = 1; i < indeks; i++) {\r\n                p = p.neste;\r\n                p.neste = new Node<>(verdi, null, p.neste);\r\n            }\r\n            antall++;\r\n            endringer++;\r\n        }\r\n        //throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean inneholder(T verdi) {\r\n        return indeksTil(verdi) != -1;\r\n    }\r\n\r\n    private Node<T> finnNode(int indeks){\r\n        //loope fra start av listen\r\n        //lønner seg å starte på slutten dersom du er over halvveis, og loope bakover\r\n        Node <T> p;\r\n        if (indeks > (antall/2)){\r\n            p = hale;\r\n            for (int i = antall; i > indeks+1; i--){\r\n                p = p.forrige;\r\n            }\r\n        } else{\r\n            p = hode;\r\n            for (int i = 0; i < indeks; i++) {\r\n                p = p.neste;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n\r\n    @Override\r\n    public T hent(int indeks) {\r\n        indeksKontroll(indeks, false);\r\n        Node <T> p = finnNode(indeks);\r\n        return p.verdi;\r\n    }\r\n\r\n    @Override\r\n    public int indeksTil(T verdi) {\r\n        if(hode == null){\r\n            return -1;\r\n        }\r\n\r\n        Node<T> current = hode;\r\n\r\n        for(int i = 0; i<antall; ++i){\r\n            if(current.verdi.equals(verdi)){\r\n                return i;\r\n            }\r\n            current = current.neste;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    @Override\r\n    public T oppdater(int indeks, T nyverdi) {\r\n        //metoden skal erstatte verdien på plass indeks med nyverdi og returnere det som lå der fra før\r\n        //husk! sjekk indeks, null-verdier skal ikke legges inn, variabelen endringer skal økes\r\n        Objects.requireNonNull(nyverdi, \"Ikke lov med null-verdier\");\r\n        indeksKontroll(indeks, false);\r\n        Node <T> p = finnNode(indeks);\r\n        T gammelVerdi = p.verdi;\r\n        p.verdi = nyverdi;\r\n        endringer++;\r\n        return gammelVerdi;\r\n    }\r\n\r\n    @Override\r\n    public boolean fjern(T verdi) { throw new UnsupportedOperationException(); }\r\n\r\n    @Override\r\n    public T fjern(int indeks) { throw new UnsupportedOperationException(); }\r\n\r\n    @Override\r\n    public void nullstill() {\r\n        /*\r\n        Lag metoden void nullstill(). Den skal «tømme» listen og nulle alt slik at\r\n        «søppeltømmeren» kan hente alt som ikke lenger brukes. Kod den på to måter\r\n        og velg den som er mest effektiv (gjør tidsmålinger):\r\n         */\r\n\r\n        // 1.metode:\r\n        // Får feil på test 7b og 7c.\r\n\r\n        Node<T> p = hode;\r\n        Node<T> q;\r\n        Node<T> r = hale;\r\n\r\n        while (p != null)\r\n        {\r\n            q = p.neste;\r\n            p.verdi = null;\r\n            p.neste = null;\r\n            p.forrige = null;\r\n            p = q;\r\n        }\r\n\r\n        /*Til slutt:\r\n          Sett både hode og hale til null, antall til 0 og endringer økes.\r\n\r\n          Metoden clear() i klassen LinkedList i Java.\r\n        */\r\n        p = null;\r\n        r = null;\r\n        antall = 0;\r\n        endringer++;\r\n\r\n        /*2.måte:\r\n          Lag en løkke som inneholder metodekallet fjern(0) (den første\r\n          noden fjernes) og som går inntil listen er tom.\r\n         */\r\n\r\n    }\r\n\r\n    //Y\r\n    @Override\r\n    public String toString() throws UnsupportedOperationException{\r\n        StringBuilder s = new StringBuilder();\r\n\r\n        s.append('[');\r\n\r\n        if (!tom())\r\n        {\r\n            Node<T> p = hode;\r\n            s.append(p.verdi);\r\n\r\n            p = p.neste;\r\n\r\n            while (p != null)  // tar med resten hvis det er noe mer\r\n            {\r\n                s.append(',').append(' ').append(p.verdi);\r\n                p = p.neste;\r\n            }\r\n        }\r\n\r\n        s.append(']');\r\n\r\n        return s.toString();\r\n\r\n        //throw new UnsupportedOperationException();\r\n    }\r\n\r\n    //Y\r\n    public String omvendtString() {\r\n        StringBuilder s = new StringBuilder();\r\n\r\n        s.append('[');\r\n\r\n        if (!tom())\r\n        {\r\n            Node<T> p = hale;\r\n            s.append(p.verdi);\r\n\r\n            p = p.forrige;\r\n\r\n            while (p != null)  // tar med resten hvis det er noe mer\r\n            {\r\n                s.append(',').append(' ').append(p.verdi);\r\n                p = p.forrige;\r\n            }\r\n        }\r\n\r\n        s.append(']');\r\n\r\n        return s.toString();\r\n\r\n        //throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public Iterator<T> iterator() {\r\n        //8b:\r\n        return new DobbeltLenketListeIterator();\r\n    }\r\n\r\n    public Iterator<T> iterator(int indeks) {\r\n        //8d;\r\n        /*\r\n        if (indeksKontroll(indeks, false)) {\r\n           return new DobbeltLenketListeIterator(indeks);\r\n        }\r\n         */\r\n        throw new UnsupportedOperationException();\r\n\r\n    }\r\n\r\n    private class DobbeltLenketListeIterator implements Iterator<T>\r\n    {\r\n        private Node<T> denne;\r\n        private boolean fjernOK;\r\n        private int iteratorendringer;\r\n\r\n        private DobbeltLenketListeIterator(){\r\n            denne = hode;     // p starter på den første i listen\r\n            fjernOK = false;  // blir sann når next() kalles\r\n            iteratorendringer = endringer;  // teller endringer\r\n        }\r\n\r\n        private DobbeltLenketListeIterator(int indeks){\r\n            //8c:\r\n            denne = finnNode(indeks);\r\n            fjernOK = false;\r\n            iteratorendringer = endringer;\r\n        }\r\n\r\n        @Override\r\n        public boolean hasNext(){\r\n            return denne != null;\r\n        }\r\n\r\n        @Override\r\n        public T next(){\r\n            // 8a:\r\n            if (iteratorendringer != endringer) {\r\n                throw new ConcurrentModificationException(\"Iteratorendringer er ikke lik endringer\");\r\n            }\r\n\r\n            if (hasNext() == false) {\r\n                throw new NoSuchElementException(\"Ikke flere verdier igjen i listen!\");\r\n            }\r\n\r\n            fjernOK = true;\r\n            T midlertidig = denne.verdi;\r\n            denne = denne.neste;\r\n\r\n            return midlertidig;\r\n        }\r\n\r\n        @Override\r\n        public void remove(){\r\n\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n    } // class DobbeltLenketListeIterator\r\n\r\n    public static <T> void sorter(Liste<T> liste, Comparator<? super T> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n} // class DobbeltLenketListe\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Oblig2/DobbeltLenketListe.java	(revision 849bbe8d63f500d5078e15923a0e84b8a67da2e0)
+++ src/Oblig2/DobbeltLenketListe.java	(date 1602178767642)
@@ -336,7 +336,6 @@
         }
          */
         throw new UnsupportedOperationException();
-
     }
 
     private class DobbeltLenketListeIterator implements Iterator<T>
